---
tags: #parasite #phase-08 #firmware #rust #sentinel #guardian #reporter
version: 1.1
status: In Progress
author: princetheprogrammer
---

# Phase 08: Firmware Core Development â€” Sentinel, Guardian & Reporter Implementation

## Document Metadata
| Field | Value |
|-------|-------|
| Phase | 08 |
| Title | Firmware Core Development |
| Version | 1.1 |
| Last Updated | 2025-12-16 |
| Author | princetheprogrammer |
| Dependencies | [[03_System_Architecture]], [[06_Bootloader_Design]] |

---

## 1. Executive Summary

This document provides the detailed implementation plan for the PARASITE firmware core. This phase represents the heart of the software development effort, translating the system architecture and security designs into functional, efficient, and secure embedded Rust code. The core consists of three primary components, designed as cooperative, state-driven modules: **Sentinel** (the detection engine), **Guardian** (the containment engine), and **Reporter** (the telemetry engine).

The implementation will be done entirely in `no_std` Rust to ensure memory safety and achieve the stringent code size and performance targets. Development will take place on the hardware prototypes specified in Phase 07, using the toolchain defined in the master project index.

-   **Sentinel:** We will implement the Sentinel's entropy scanning logic using fixed-point arithmetic for the Chi-squared calculation. It will be driven by a hardware timer and will run as a low-priority background task, continuously scanning the application's executable memory regions.
-   **Guardian:** The Guardian will be implemented as a reactive module, triggered primarily by hardware exceptions (e.g., Memory Management Faults) and high-confidence alerts from the Sentinel. Its core logic will involve direct manipulation of the MCU's Memory Protection Unit (MPU) via the defined Hardware Abstraction Layer (HAL) to quarantine suspect memory regions.
-   **Reporter:** The Reporter module will manage a queue of threat reports generated by the Guardian. We will implement the logic to serialize these reports into a compact Protobuf format and then use the `p256` and `chacha20poly1305` Rust crates to establish a secure mTLS session with the backend verifier for transmission.

This document provides detailed data structures, state machine diagrams, and foundational Rust code snippets for each component. These snippets serve as a practical starting point, illustrating key concepts like fixed-point math, HAL interaction, and inter-component communication via lock-free queues. The final deliverable of this phase will be a compiled firmware binary containing the complete, integrated PARASITE core, ready for system integration and testing.

---

## 2. Development Environment & Principles

-   **Language:** Rust (2021 edition), using the `thumbv7em-none-eabihf` target for the STM32 prototype.
-   **Build System:** `cargo` with a custom `build.rs` script and linker script to manage memory layout.
-   **Key Crates:** `cortex-m`, `cortex-m-rt`, `defmt` (for logging), `heapless` (for static data structures), `p256`, `chacha20poly1305`.
-   **Concurrency:** We will use a simple cooperative scheduling model. Components are "tasks" that are polled in a main superloop. Communication is handled via `heapless::spsc::Queue`, a lock-free, single-producer, single-consumer queue suitable for concurrent access without mutexes.
-   **Error Handling:** All functions will return `Result<T, Error>`. Errors are defined as a comprehensive `enum` and propagated up. A global error handler will catch unrecoverable errors, log a final diagnostic message, and place the device in a fail-secure state.

---

## 3. Sentinel: The Detection Engine

The Sentinel's job is to continuously "sweep" the application's memory, looking for anomalous patterns.

### 3.1 Data Structures & State

```rust
// sentinel/mod.rs

use heapless::spsc::Producer;
use crate::hal::ParasiteHal;
use crate::events::KernelEvent;

pub struct Sentinel<'a> {
    // Hardware Abstraction Layer
    hal: &'a dyn ParasiteHal,
    // Queue to send alerts to the Guardian
    producer: Producer<'a, KernelEvent, 16>, 
    // The memory regions to scan
    scan_regions: &'static [MemoryRegion],
    // Current position in the scan
    current_addr: usize, 
    // State machine
    state: SentinelState,
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub struct MemoryRegion {
    pub start: usize,
    pub end: usize,
}

enum SentinelState {
    Idle,
    Scanning,
}

```

### 3.2 Core Logic: The Scan Loop

The main `poll` function is called repeatedly from the main superloop. A timer interrupt sets a flag that triggers a state transition from `Idle` to `Scanning`.

```rust
// sentinel/mod.rs

const WINDOW_SIZE: usize = 512;
const STRIDE: usize = 256; // Overlapping windows
const ENTROPY_THRESHOLD: u32 = 180_000; // Example fixed-point threshold

impl<'a> Sentinel<'a> {
    
    // Called in the main loop of the firmware
    pub fn poll(&mut self) {
        if self.state == SentinelState::Idle {
            // A timer interrupt would set a flag to transition state.
            // For simplicity, we'll just start scanning.
            self.state = SentinelState::Scanning;
        }

        if self.state == SentinelState::Scanning {
            self.perform_scan_slice();
        }
    }

    /// Scans one slice of memory and advances the scan pointer.
    fn perform_scan_slice(&mut self) {
        let current_region = self.get_current_region()?;

        // Ensure we don't scan past the end of the current region
        if self.current_addr + WINDOW_SIZE > current_region.end {
            self.go_to_next_region();
            return;
        }

        // Create a slice of the memory to be scanned.
        // This is highly unsafe and is the core of PARASITE's functionality.
        // It MUST be guaranteed by the MPU that we can only read from valid app memory.
        let window = unsafe {
            core::slice::from_raw_parts(self.current_addr as *const u8, WINDOW_SIZE)
        };
        
        let entropy_score = self.calculate_entropy(window);

        if entropy_score < ENTROPY_THRESHOLD { // Low score = high entropy
            let event = KernelEvent::HighEntropyDetected {
                address: self.current_addr,
                score: entropy_score,
            };
            
            // Attempt to queue the alert for the Guardian.
            // If the queue is full, the alert is dropped. This is a deliberate
            // choice to prevent a DoS attack from filling the queue.
            self.producer.enqueue(event).ok();
        }

        self.current_addr += STRIDE;
    }

    /// Calculates a fixed-point Chi-squared statistic.
    fn calculate_entropy(&self, window: &[u8]) -> u32 {
        // Implementation of fixed-point Chi-squared calculation
        // as defined in the Phase 01 research document.
        // ... returns a u32 score
        0 // Placeholder
    }
    
    // ... helper functions like get_current_region(), go_to_next_region() ...
}
```

---

## 4. Guardian: The Containment Engine

The Guardian's role is purely reactive. It sleeps until an event requires its attention.

### 4.1 Data Structures & State

```rust
// guardian/mod.rs

use heapless::spsc::Consumer;
use crate::hal::ParasiteHal;
use crate::events::KernelEvent;

pub struct Guardian<'a> {
    hal: &'a dyn ParasiteHal,
    // Queue to receive alerts from Sentinel
    consumer: Consumer<'a, KernelEvent, 16>,
    // Queue to send reports to Reporter
    producer: Producer<'a, ThreatReport, 8>,
    // Tracks which MPU regions are in use for quarantine
    quarantined_regions: [bool; 8], 
}

pub struct ThreatReport {
    pub source: ReportSource,
    pub address: usize,
    pub pc: usize, // Program Counter, if available
}

pub enum ReportSource {
    Sentinel,
    MemManageFault,
    HardFault,
}
```

### 4.2 Core Logic: Handling Events and Faults

The `poll` function checks the queue, while the `on_memmanage_fault` function is registered as the hardware exception handler.

```rust
// guardian/mod.rs

impl<'a> Guardian<'a> {
    
    // Called in the main loop of the firmware
    pub fn poll(&mut self) {
        // Check for an event from the Sentinel
        if let Some(event) = self.consumer.dequeue() {
            match event {
                KernelEvent::HighEntropyDetected { address, score } => {
                    self.handle_entropy_alert(address, score);
                }
            }
        }
    }

    /// This function is registered as the memory management fault handler.
    #[exception]
    fn on_memmanage_fault(stack_frame: &cortex_m_rt::ExceptionFrame) {
        // A memory protection violation has occurred!
        // This is a high-confidence indicator of malicious activity.
        
        let faulting_pc = stack_frame.pc() as usize; // Where the fault happened
        let faulting_addr = Self::get_faulting_address(); // Read from fault status register
        
        // Immediately quarantine the code that caused the fault.
        // This is a simplified example; a real implementation would need
        // to identify the region based on the faulting PC.
        self.quarantine_and_report(faulting_addr, ReportSource::MemManageFault, faulting_pc);
        
        // The thread that caused the fault cannot continue.
        // Depending on policy, we might terminate the thread or reset.
        // For now, we enter an infinite loop to halt execution.
        loop {}
    }

    fn handle_entropy_alert(&mut self, address: usize, score: u32) {
        // Policy: Do we quarantine immediately or wait for more evidence?
        // For now, our policy is to quarantine on any high-confidence alert.
        self.quarantine_and_report(address, ReportSource::Sentinel, 0);
    }
    
    /// The core quarantine logic.
    fn quarantine_and_report(&mut self, address: usize, source: ReportSource, pc: usize) {
        if let Some(region_id) = self.find_free_region() {
            // Use the HAL to configure the MPU
            let result = self.hal.mpu_quarantine_region(
                region_id,
                address,
                WINDOW_SIZE // Quarantine the entire anomalous window
            );

            if result.is_ok() {
                self.quarantined_regions[region_id as usize] = true;
                
                // Create a report for the Reporter module
                let report = ThreatReport { source, address, pc };
                self.producer.enqueue(report).ok();
            }
        }
        // If no free regions, we can't quarantine. We should escalate
        // by creating a special ThreatReport.
    }

    fn find_free_region(&self) -> Option<u8> {
        self.quarantined_regions.iter().position(|&used| !used).map(|i| i as u8)
    }
}
```

---

## 5. Reporter: The Telemetry Engine

The Reporter is a state machine that handles the complexity of secure network communication.

### 5.1 Data Structures & State

```rust
// reporter/mod.rs

use heapless::{spsc::Consumer, Vec};
use crate::hal::ParasiteHal;
use crate::guardian::ThreatReport;

pub struct Reporter<'a> {
    hal: &'a dyn ParasiteHal,
    // Queue to receive reports from Guardian
    consumer: Consumer<'a, ThreatReport, 8>,
    // State machine
    state: ReporterState,
    // Buffer for the report we are currently trying to send
    pending_report: Option<ThreatReport>,
    // Buffer for the serialized TLS payload
    tx_buffer: Vec<u8, 512>, 
}

enum ReporterState {
    Idle,
    Serializing,
    Connecting,
    Transmitting,
}
```

### 5.2 Core Logic: The State Machine

The `poll` function drives the state machine, moving from one state to the next upon success.

```rust
// reporter/mod.rs

impl<'a> Reporter<'a> {

    // Called in the main loop of the firmware
    pub fn poll(&mut self) {
        match self.state {
            ReporterState::Idle => {
                // If we don't have a pending report, try to get one
                if self.pending_report.is_none() {
                    self.pending_report = self.consumer.dequeue();
                }
                // If we have a report, start processing it
                if self.pending_report.is_some() {
                    self.state = ReporterState::Serializing;
                }
            }
            ReporterState::Serializing => {
                if let Some(report) = &self.pending_report {
                    // 1. Serialize the ThreatReport into a compact format (e.g. nanopb)
                    let serialized_data = self.serialize_report(report);
                    
                    // 2. Establish a secure session and encrypt the data
                    // This is a highly complex process involving:
                    //   - Getting device key from HAL
                    //   - Performing ECDH key exchange
                    //   - Encrypting with ChaCha20-Poly1305
                    match self.encrypt_payload(&serialized_data) {
                        Ok(encrypted_payload) => {
                            self.tx_buffer.clear();
                            self.tx_buffer.extend_from_slice(&encrypted_payload).unwrap();
                            self.state = ReporterState::Connecting;
                        }
                        Err(_) => {
                            // Crypto failed, discard report and go to idle
                            self.pending_report = None;
                            self.state = ReporterState::Idle;
                        }
                    }
                }
            }
            ReporterState::Connecting => {
                // Use the HAL to open a TCP socket to the backend
                match self.hal.net_tcp_connect("verify.parasite.gov.in", 443) {
                    Ok(socket) => {
                        self.state = ReporterState::Transmitting { handle: socket };
                    }
                    Err(_) => {
                        // Network connection failed. Retry later.
                        self.state = ReporterState::Idle;
                    }
                }
            }
            ReporterState::Transmitting { handle } => {
                // Use the HAL to write the encrypted data
                match self.hal.net_tcp_write(handle, &self.tx_buffer) {
                    Ok(bytes_written) if bytes_written == self.tx_buffer.len() => {
                        // Success! Report sent.
                        self.pending_report = None;
                        self.state = ReporterState::Idle;
                    }
                    _ => {
                        // Write failed. Close socket and retry later.
                        // A more robust implementation would have more complex retry logic.
                        self.state = ReporterState::Idle;
                    }
                }
            }
        }
    }
    
    // ... serialize_report() and encrypt_payload() helper methods ...
}

```
This implementation provides a clear, state-driven, and robust framework for developing the PARASITE core, with a strong emphasis on security, efficiency, and safety through the use of Rust.
