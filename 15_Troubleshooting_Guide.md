---
tags: #parasite #phase-15 #troubleshooting #debugging #fmea
version: 1.1
status: In Progress
author: princetheprogrammer
---

# Phase 15: Troubleshooting Guide â€” Debugging & Failure Mode Analysis

## Document Metadata
| Field | Value |
|-------|-------|
| Phase | 15 |
| Title | Troubleshooting Guide |
| Version | 1.1 |
| Last Updated | 2025-12-16 |
| Author | princetheprogrammer |
| Dependencies | [[08_Firmware_Core_Development]], [[14_Testing_and_Certification]] |

---

## 1. Executive Summary

This document provides a comprehensive troubleshooting and debugging guide for the PARASITE ecosystem. While previous phases have focused on design and implementation for success, this document addresses the inevitability of failures, whether they occur during development, testing, or field deployment. Its purpose is to serve as a first-line-of-defense manual for engineers and operators, enabling them to rapidly diagnose and resolve issues in a systematic manner.

The guide is structured into three main sections:
1.  **Common Failure Scenarios:** A problem-oriented guide that addresses common issues such as device boot failures, attestation errors, or network connectivity problems. For each scenario, it provides a step-by-step diagnostic workflow, from simple visual checks to deep dives with debugging tools.
2.  **Interpreting Logs & Error Codes:** This section provides a reference for understanding the structured `defmt` logs generated by the firmware. It details the meaning of different log levels, error enums, and the diagnostic information they provide.
3.  **Failure Mode and Effects Analysis (FMEA):** A proactive analysis of potential failure modes within the system. The FMEA table identifies potential causes and effects of failures in hardware and software, providing insights into the system's weak points and informing future design improvements.

This document is intended to be a living guide, continuously updated with new findings as the project matures. By providing clear, actionable diagnostic procedures, it aims to reduce downtime, streamline the development process, and enhance the overall reliability and maintainability of the PARASITE system.

---

## 2. Common Failure Scenarios & Diagnostic Workflows

### Scenario 1: Device Fails to Boot
-   **Symptom:** The device is powered on, but there is no activity. No LEDs are blinking, and there is no console output.
-   **Diagnostic Workflow:**
    1.  **Power Check (Hardware):**
        -   Verify the power source is providing the correct voltage (5V).
        -   Measure the main `+3V3` rail on the board. If it's not 3.3V, investigate the PSU block (Step 3 of the Phase 07 bring-up plan).
    2.  **Clock Check (Hardware):**
        -   Use an oscilloscope to check for a valid clock signal at the MCU's main crystal. A missing or unstable clock is a common cause of boot failure.
    3.  **Debugger Connection (Firmware):**
        -   Attempt to connect with a J-Link/ST-Link debugger.
        -   **If connection fails:** This points to a fundamental hardware issue (power, clock, or a damaged MCU). Re-verify the hardware bring-up plan.
        -   **If connection succeeds:** The hardware is likely okay. The issue is in the very early stage of the software.
    4.  **Read CPU State (Debugger):**
        -   Halt the CPU and read the Program Counter (PC).
        -   If the PC is at the `HardFault_Handler` address (or a similar default fault handler), it means the code crashed immediately on startup. This often points to a memory alignment issue, a corrupted stack pointer, or a flaw in the early `crt0` startup code.
        -   If the PC is stuck in the bootloader, it means firmware verification failed. Proceed to Scenario 2.

### Scenario 2: Bootloader Rejects Firmware
-   **Symptom:** The device boots but immediately enters a loop or fails to start the main application. Debug logs from the bootloader (if enabled) may indicate an "invalid signature" or "version check failed."
-   **Diagnostic Workflow:**
    1.  **Signature Verification:**
        -   Ensure the application binary was signed with the correct private key corresponding to the public key baked into the bootloader.
        -   Verify that the entire image (header, binary, TLVs) was created correctly and that the hash in the TLV block matches the hash of the binary.
    2.  **Anti-Rollback Check:**
        -   Check the security counter value in the firmware image's TLV block.
        -   Use the debugger to read the security counter value stored in the device's non-volatile memory. The image counter must be greater than or equal to the device counter. If not, the bootloader will correctly reject it.
    3.  **Image Corruption:**
        -   The flash memory may be corrupted. Perform a full chip erase and re-flash the entire signed firmware image.

### Scenario 3: Attestation Fails
-   **Symptom:** The device is running, but the Verifier Backend reports that the device has failed an attestation check.
-   **Diagnostic Workflow:**
    1.  **Check Verifier Logs:** The backend logs are the best source of information. The log should specify *why* the verification failed.
        -   `"Invalid signature"`: This is the most critical failure. It implies the Device Identity Key may be compromised or there is a flaw in the signing/verification logic. Re-verify the key provisioning process.
        -   `"Nonce mismatch"`: This could indicate a network issue (e.g., a re-sent request) or a bug in the device's nonce handling. It is usually transient.
        -   `"Measurement mismatch"`: This is the intended failure mode for detecting tampering. It means the firmware on the device does not match the "golden" version.
    2.  **Investigate Measurement Mismatch:**
        -   If a measurement has mismatched, the backend log will indicate which one (bootloader, parasite, or application).
        -   This is a high-confidence indicator that the device's firmware has been modified. The device should be considered compromised and moved to a quarantine network for forensic analysis.

---

## 3. Interpreting Logs & Error Codes

The firmware uses the `defmt` crate for highly efficient, structured logging. Understanding the log output is key to debugging.

### 3.1 Log Levels
-   `DEFMT_TRACE`: Verbose, fine-grained information for deep debugging (e.g., "Entering function `foo`"). Disabled in release builds.
-   `DEFMT_DEBUG`: Information useful for debugging (e.g., "Sentinel scan complete, score: 12345"). Disabled in release builds.
-   `DEFMT_INFO`: Normal operational messages (e.g., "PARASITE core initialized"). Enabled in release builds.
-   `DEFMT_WARN`: Indicates a potential issue that doesn't prevent operation (e.g., "Reporter queue is full, dropping threat report").
-   `DEFMT_ERROR`: Indicates a serious, non-fatal error (e.g., "Failed to connect to backend").

### 3.2 Using `defmt` for Rich Diagnostics
`defmt` allows logging complex data structures, which is invaluable for debugging.

```rust
// This snippet shows how we might log a detailed diagnostic packet
// when a memory fault occurs.

use defmt::Format;

#[derive(Format)]
pub struct MemManageFaultInfo {
    // The program counter when the fault occurred
    pc: u32,
    // The memory address that was accessed
    fault_addr: u32,
    // Status register indicating the type of fault (e.g., instruction fetch, data access)
    cfsr: u32,
}

// In the fault handler:
fn on_memmanage_fault(stack_frame: &cortex_m_rt::ExceptionFrame) {
    let info = MemManageFaultInfo {
        pc: stack_frame.pc(),
        fault_addr: read_cfsr_address(), // A function to get fault address
        cfsr: read_cfsr_register(),     // A function to get fault status
    };
    
    // This will print a structured, human-readable log of the entire struct.
    defmt::error!("CRITICAL: Memory Management Fault! Details: {=?}", info);
}
```
An operator seeing this log message would have immediate, detailed context about the crash without needing to attach a debugger.

---

## 4. Failure Mode and Effects Analysis (FMEA)

This table proactively analyzes potential failures.

| Component | Potential Failure Mode | Potential Causes | Potential Effects | Detection Method | Mitigation |
|-----------|------------------------|------------------|-------------------|------------------|------------|
| **PSU** | 3.3V rail unstable/noisy | - Poor decoupling <br>- LDO failure | - MCU behaves erratically <br>- Crypto ops fail | Oscilloscope measurement of VCC rail. | Follow layout guidelines from Phase 05. Use high-quality LDOs. |
| **MCU** | eFuse for debug disable fails to blow | - Insufficient voltage during fusing <br>- Faulty MCU | Debug port remains open on a production device, creating a massive security hole. | Post-provisioning verification step that attempts to connect a debugger. | Redundant fuse-blowing command; fail the entire provisioning process if verification fails. |
| **Sentinel**| False positive on legitimate data | - Encrypted data in app firmware <br>- Compressed assets | Guardian quarantines valid application code, causing a functional failure (DoS). | Sentinel uses multiple heuristics. A baselining mode profiles the app on first boot. |
| **Guardian**| MPU configuration error | - Bug in HAL <br>- Incorrect memory map | MPU fails to contain a threat, or it faults on legitimate memory access. | Extensive HIL testing of MPU configurations. |
| **Reporter**| TLS Handshake Failure | - Incorrect device key <br>- Revoked certificate <br>- Network firewall blocking port | Device cannot send threat reports to the backend. | Backend logs will show TLS handshake error. Device logs will show connection failure. |
| **Backend** | Database goes down | - Cloud provider outage <br>- DB service crash | New threat reports and attestations cannot be processed. | High-availability database configuration (e.g., replicas, failover). Robust monitoring and alerting for backend services. |
| **Bootloader**| Anti-rollback counter corruption | - Power loss during counter update | Device may fail to boot a valid new firmware, or it may accept an old, vulnerable firmware. | Use a two-stage commit for the counter update. If corruption is detected, enter recovery mode. |
